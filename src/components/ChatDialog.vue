<script setup lang="ts">
import { ref, reactive, onMounted, nextTick, computed, watch, onBeforeUnmount } from 'vue';
import { getMCPClient } from '../utils/MCPClient';
import CommandStateManager from '../utils/CommandStateManager';

// 创建命令状态管理器实例
const commandStateManager = new CommandStateManager({
  commandTTL: 5000,  // 5秒内的相似命令视为重复
  lockTimeout: 8000  // 命令锁8秒超时
});

// 定义props (Define props)
const props = defineProps<{
  modelVisible: boolean;
}>();

// 定义事件 (Define events)
const emit = defineEmits(['update:modelVisible', 'executeAction']);

// 初始化MCP客户端
const mcpClient = ref(null);

// 对话记录 (Chat history)
const chatHistory = reactive<Array<{role: string, content: string, time: string, mcpOperation?: any}>>([
  { role: 'assistant', content: '您好，我是数字孪生AI助手。我可以回答您关于办公室模型的问题，也可以帮您操作3D模型。', time: formatTime(new Date()) }
]);

// 用户消息输入 (User message input)
const userMessage = ref('');
const chatContainerRef = ref<HTMLElement | null>(null);
const isLoading = ref(false);

// AI模型选择 (AI model selection)
// 移除模式选择，改为统一处理
// const selectedModel = ref('dify'); // 默认使用Dify
// const models = [
//   { value: 'dify', label: '对话模式' },
//   { value: 'mcp', label: '模型操作模式' }
// ];

// 添加selectedModel变量，修复未定义问题
const selectedModel = ref('default');

// MCP服务器状态 (MCP server status)
const mcpServerStatus = ref('unknown');

// 计算MCP是否可用 (Compute if MCP is available)
const isMCPAvailable = computed(() => {
  // 检查并在控制台输出当前状态
  console.log('MCP服务器状态:', mcpServerStatus.value);
  
  // 放宽条件，只要不是明确的offline状态，都认为可用
  // 这样可以解决状态检测滞后问题
  return mcpServerStatus.value !== 'offline';
});

// 计算是否使用MCP模式 - 移除这个，因为现在统一处理
// const isMCPMode = computed(() => {
//   return selectedModel.value === 'mcp';
// });

// 关闭对话框 (Close dialog)
const closeDialog = () => {
  emit('update:modelVisible', false);
};

// 添加延迟函数
const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

// 发送消息并处理AI响应
const sendMessage = async () => {
  if (!userMessage.value.trim()) return;
  
  // 清除输入框并添加用户消息到历史记录
  const userMessageText = userMessage.value.trim();
  userMessage.value = '';
  
  chatHistory.push({
    role: 'user',
    content: userMessageText,
    time: formatTime(new Date())
  });
  
  // 滚动到底部
  await nextTick();
  scrollToBottom();
  
  // 设置加载状态
  isLoading.value = true;
  
  try {
    // 设置正在处理标记
    window.isProcessingAICommand = true;
    
    // 检测是否有操作指令(备用)
    const detectedOperation = detectOperation(userMessageText);
    
    // 如果检测到操作指令，先注册但不立即执行
    let pendingCommandKey = null;
    if (detectedOperation) {
      pendingCommandKey = commandStateManager.registerCommand(
        detectedOperation.operation, 
        detectedOperation.parameters
      );
      sessionStorage.setItem('pending_command_key', pendingCommandKey);
      
      // 记录操作类型到会话存储，防止重复执行
      sessionStorage.setItem('last_mcp_operation_type', detectedOperation.operation);
      sessionStorage.setItem('last_mcp_operation_time', Date.now().toString());
      console.log(`已注册操作指令: ${detectedOperation.operation}，等待AI响应后执行`);
    }
    
    // 发送消息到AI服务
    const aiResponse = await sendToDifyServer(userMessageText);
    
    // 添加AI回复到历史记录
    if (aiResponse && aiResponse.success) {
      chatHistory.push({
        role: 'assistant',
        content: aiResponse.text,
        time: formatTime(new Date())
      });
      
      // 检查是否有操作指令
      if (aiResponse.operation || aiResponse.action) {
        try {
          // 延迟执行模型操作，等待AI回复显示
          console.log('延迟执行模型操作，等待AI回复显示...');
          await delay(1000);
          
          // 标准化操作对象
          const actionObj = {
            type: aiResponse.operation || (aiResponse.action && aiResponse.action.type),
            params: aiResponse.parameters || aiResponse.action?.params || {}
          };
          
          // 尝试检查角度参数
          if (actionObj.type === 'rotate' && sessionStorage.getItem('requested_angle')) {
            const requestedAngle = parseInt(sessionStorage.getItem('requested_angle') || '45');
            if (actionObj.params.angle && actionObj.params.angle !== requestedAngle) {
              console.log(`修正旋转角度: 从${actionObj.params.angle}°改为${requestedAngle}°`);
              actionObj.params.angle = requestedAngle;
            }
          }
          
          // 确保zoom操作的参数正确
          if (actionObj.type === 'zoom') {
            // 确保有缩放参数，没有就使用默认值1.5
            if (!actionObj.params.scale && !actionObj.params.scaleOrFactor) {
              actionObj.params.scale = 1.5;
            }
            // 使用可能存在的其他名称的缩放参数
            else if (!actionObj.params.scale && actionObj.params.scaleOrFactor) {
              actionObj.params.scale = actionObj.params.scaleOrFactor;
            }
            // 确保缩放参数是浮点数
            actionObj.params.scale = parseFloat(actionObj.params.scale);
            console.log(`缩放操作参数已标准化: scale=${actionObj.params.scale}`);
          }
          
          // 确保focus操作的参数正确
          if (actionObj.type === 'focus' && !actionObj.params.target) {
            actionObj.params.target = actionObj.params.objectName || 'center';
          }
          
          // 检查是否近期已执行过相似命令
          if (commandStateManager.isCommandExecuted(actionObj.type, actionObj.params)) {
            console.log(`近期已执行过相似的${actionObj.type}命令，跳过执行`);
          } else {
            // 尝试获取执行锁
            if (commandStateManager.acquireLock()) {
              try {
                console.log('现在执行模型操作:', actionObj);
                
                // 记录操作到会话存储中，确保后续可以使用
                if (actionObj.type) {
                  sessionStorage.setItem('last_mcp_operation_type', actionObj.type);
                  if (actionObj.type === 'zoom' && actionObj.params.scale) {
                    sessionStorage.setItem('requested_scale', actionObj.params.scale.toString());
                  } else if (actionObj.type === 'rotate') {
                    if (actionObj.params.angle) {
                      sessionStorage.setItem('requested_angle', actionObj.params.angle.toString());
                    }
                    if (actionObj.params.direction) {
                      sessionStorage.setItem('requested_direction', actionObj.params.direction);
                    }
                  } else if (actionObj.type === 'focus' && actionObj.params.target) {
                    sessionStorage.setItem('requested_target', actionObj.params.target);
                  }
                }
                
                // 发送命令到父组件执行
                emit('executeAction', actionObj);
                
                // 如果有pending命令，标记为已执行
                if (pendingCommandKey) {
                  commandStateManager.markAsExecuted(pendingCommandKey);
                } else {
                  // 注册并标记新命令为已执行
                  const newCommandKey = commandStateManager.registerCommand(
                    actionObj.type, 
                    actionObj.params
                  );
                  commandStateManager.markAsExecuted(newCommandKey);
                }
                
                // 确保命令已发出后才执行队列命令 - 增加延迟时间
                await delay(500);
              } finally {
                // 释放执行锁
                commandStateManager.releaseLock();
              }
            } else {
              console.log('无法获取命令执行锁，跳过执行');
            }
          }
          
          // 移除正在处理标记
          window.isProcessingAICommand = false;
        } catch (operationError) {
          console.error('执行操作失败:', operationError);
          window.isProcessingAICommand = false;
        }
      } else {
        // 如果没有操作指令，移除正在处理标记
        window.isProcessingAICommand = false;
      }
    } else {
      // 处理失败情况
      chatHistory.push({
        role: 'assistant',
        content: aiResponse?.text || '处理消息时发生错误',
        time: formatTime(new Date()),
        error: true
      });
      
      // 移除正在处理标记
      window.isProcessingAICommand = false;
    }
  } catch (error) {
    console.error('请求错误:', error);
    // 添加错误消息到历史记录
    chatHistory.push({
      role: 'assistant',
      content: `抱歉，发生了错误: ${(error as Error).message}`,
      time: formatTime(new Date()),
      error: true
    });
    
    // 移除正在处理标记
    window.isProcessingAICommand = false;
  } finally {
    isLoading.value = false;
    
    // 滚动到底部
    await nextTick();
    scrollToBottom();
  }
};

// 执行队列中的命令 - 减少直接调用
const executeQueuedCommands = () => {
  // 检查是否有最近执行的命令
  const lastOpType = sessionStorage.getItem('last_mcp_operation_type');
  const lastOpTime = sessionStorage.getItem('last_mcp_operation_time');
  
  if (lastOpType && lastOpTime) {
    // 检查命令执行时间是否过近(5秒内)
    const now = Date.now();
    const lastTime = parseInt(lastOpTime);
    if (now - lastTime < 5000) {
      console.log(`命令${lastOpType}在5秒内已执行过，跳过重复执行`);
      return;
    }
  }
  
  // 获取模型查看器引用
  const modelViewer = findModelViewerReference();
  
  if (!modelViewer) {
    console.warn('无法找到模型查看器引用，尝试通过全局事件执行命令');
    
    // 尝试通过事件触发执行队列命令
    window.dispatchEvent(new CustomEvent('execute-queued-commands'));
    
    // 尝试直接调用全局对象上的方法
    if (window.app && typeof window.app.executeQueuedCommands === 'function') {
      console.log('使用全局app对象执行队列命令');
      window.app.executeQueuedCommands();
      return;
    }
    
    // 尝试使用直接的全局方法 - 这里不获取锁，因为tryDirectGlobalMethod内部会获取锁
    if (lastOpType) {
      console.log('尝试使用全局方法执行最后的操作:', lastOpType);
      tryDirectGlobalMethod(lastOpType);
    }
    
    return;
  }
  
  console.log('找到模型查看器引用:', modelViewer);
  
  // 检查是否有命令队列和执行方法
  if (modelViewer.commandQueue && typeof modelViewer.executeQueuedCommands === 'function') {
    console.log('调用ModelViewer.executeQueuedCommands执行队列命令');
    
    // 先检查MCP服务器状态
    checkMCPServerStatus().then(isAvailable => {
      if (!isAvailable) {
        console.warn('MCP服务器不可用，命令执行可能失败');
      }
      
      // 尝试获取命令执行锁
      if (commandStateManager.acquireLock()) {
        try {
          // 无论MCP状态如何，都尝试执行命令
          try {
            modelViewer.executeQueuedCommands();
          } catch (error) {
            console.error('执行队列命令失败:', error);
            
            // 如果执行失败，尝试直接执行具体操作
            tryExecuteDirectOperations(modelViewer);
          }
        } finally {
          // 确保释放锁
          commandStateManager.releaseLock();
        }
      } else {
        console.log('无法获取命令执行锁，跳过执行队列命令');
      }
    });
  } else if (modelViewer.rotateComponent || modelViewer.zoomComponent || 
             modelViewer.rotateModel || modelViewer.zoomModel) {
    console.log('模型查看器不支持命令队列，但支持直接操作方法');
    // 尝试获取锁执行直接操作
    if (commandStateManager.acquireLock()) {
      try {
        tryExecuteDirectOperations(modelViewer);
      } finally {
        commandStateManager.releaseLock();
      }
    }
  } else {
    console.error('模型查看器不支持命令队列或操作方法');
    // 尝试使用全局方法 - 这里不获取锁，因为tryDirectGlobalMethod内部会获取锁
    if (lastOpType) {
      console.log('尝试使用全局方法执行最后的操作:', lastOpType);
      tryDirectGlobalMethod(lastOpType);
    }
  }
};

// 尝试直接使用全局方法执行操作
const tryDirectGlobalMethod = (opType) => {
  // 检查是否近期已执行过相似命令
  let params = {};
  
  switch(opType.toLowerCase()) {
    case 'zoom':
      params = { scale: parseFloat(sessionStorage.getItem('requested_scale') || '1.5') };
      break;
    case 'rotate':
      params = {
        angle: parseInt(sessionStorage.getItem('requested_angle') || '45'),
        direction: sessionStorage.getItem('requested_direction') || 'left'
      };
      break;
    case 'focus':
      params = { target: sessionStorage.getItem('requested_target') || 'center' };
      break;
  }
  
  if (commandStateManager.isCommandExecuted(opType, params)) {
    console.log(`近期已执行过相似的${opType}命令，跳过执行`);
    return false;
  }
  
  // 尝试获取执行锁
  if (!commandStateManager.acquireLock()) {
    console.log('无法获取命令执行锁，跳过全局方法执行');
    return false;
  }
  
  let executed = false;
  
  try {
    // 注册新命令
    const commandKey = commandStateManager.registerCommand(opType, params);
    
    switch(opType.toLowerCase()) {
      case 'zoom':
        if (typeof window.zoomModel === 'function') {
          const scale = parseFloat(sessionStorage.getItem('requested_scale') || '1.5');
          console.log(`使用全局zoomModel方法：比例=${scale}`);
          window.zoomModel({ scale });
          executed = true;
        }
        break;
      case 'rotate':
        if (typeof window.rotateModel === 'function') {
          const angle = parseInt(sessionStorage.getItem('requested_angle') || '45');
          const direction = sessionStorage.getItem('requested_direction') || 'left';
          console.log(`使用全局rotateModel方法：角度=${angle}, 方向=${direction}`);
          window.rotateModel({ direction, angle });
          executed = true;
        }
        break;
      case 'focus':
        if (typeof window.focusModel === 'function') {
          const target = sessionStorage.getItem('requested_target') || 'center';
          console.log(`使用全局focusModel方法：目标=${target}`);
          window.focusModel({ target });
          executed = true;
        }
        break;
      case 'reset':
        if (typeof window.resetModel === 'function') {
          console.log('使用全局resetModel方法');
          window.resetModel();
          executed = true;
        }
        break;
    }
    
    // 如果执行成功，标记命令为已执行
    if (executed) {
      commandStateManager.markAsExecuted(commandKey);
    }
    
    return executed;
  } finally {
    // 确保释放执行锁
    commandStateManager.releaseLock();
  }
};

// 查找模型查看器引用的辅助函数
const findModelViewerReference = () => {
  console.log('尝试查找模型查看器引用...');
  
  // 方法1: 从父组件获取
  try {
    const parentElement = document.querySelector('.chat-dialog')?.parentElement;
    if (parentElement) {
      // Vue 3方式
      const modelViewer = parentElement.__vue__?.refs?.modelViewer || 
                          parentElement.__vue__?.setupState?.modelViewerRef?.value;
      if (modelViewer) {
        console.log('从父组件获取到ModelViewer引用');
        return modelViewer;
      }
    }
  } catch (e) {
    console.error('从父组件获取模型查看器引用失败:', e);
  }
  
  // 方法2: 直接从DOM获取
  try {
    const modelViewerElement = document.querySelector('.model-container')?.firstElementChild;
    if (modelViewerElement && modelViewerElement.__vue__) {
      console.log('从DOM直接获取到ModelViewer引用');
      return modelViewerElement.__vue__;
    }
  } catch (e) {
    console.error('从DOM获取模型查看器引用失败:', e);
  }
  
  // 方法3: 通过全局变量获取
  try {
    if (window.__scene && window.__camera && window.__controls) {
      console.log('从全局THREE.js对象识别到ModelViewer');
      // 尝试返回window对象上可能存在的ModelViewer实例
      if (window.modelViewer) {
        return window.modelViewer;
      }
      // 如果找不到直接的引用，尝试通过全局方法判断
      if (typeof window.zoomModel === 'function' &&
          typeof window.rotateModel === 'function' &&
          typeof window.focusModel === 'function') {
        console.log('找到全局模型操作方法，返回代理对象');
        // 创建一个代理对象，将全局方法包装起来
        return {
          commandQueue: [],
          executeQueuedCommands: () => {
            console.log('使用全局方法执行队列命令');
            return true;
          },
          zoomModel: window.zoomModel,
          rotateModel: window.rotateModel,
          focusModel: window.focusModel,
          resetModel: window.resetModel
        };
      }
    }
  } catch (e) {
    console.error('从全局THREE.js对象获取模型查看器引用失败:', e);
  }
  
  // 方法4: 获取canvas元素但正确处理
  try {
    const canvas = document.getElementById('modelViewer');
    if (canvas) {
      console.log('找到modelViewer canvas元素');
      
      // 通过父元素向上寻找Vue组件实例
      let element = canvas;
      while (element && !element.__vue__) {
        element = element.parentElement;
      }
      
      if (element && element.__vue__) {
        console.log('从canvas父元素找到ModelViewer组件实例');
        return element.__vue__;
      }
      
      // 如果找不到组件实例，但全局有操作方法，创建代理对象
      if (typeof window.zoomModel === 'function' || 
          typeof window.rotateModel === 'function') {
        console.log('找到canvas元素并有全局方法，返回代理对象');
        return {
          commandQueue: [],
          executeQueuedCommands: () => {
            console.log('canvas代理：使用全局方法执行队列命令');
            return true;
          },
          zoomModel: typeof window.zoomModel === 'function' ? window.zoomModel : null,
          rotateModel: typeof window.rotateModel === 'function' ? window.rotateModel : null,
          focusModel: typeof window.focusModel === 'function' ? window.focusModel : null,
          resetModel: typeof window.resetModel === 'function' ? window.resetModel : null
        };
      }
      
      // 返回null以避免返回canvas元素
      return null;
    }
  } catch (e) {
    console.error('通过canvas查找模型查看器引用失败:', e);
  }
  
  // 方法5: 使用全局对象
  try {
    if (window.app && typeof window.app.zoomComponent === 'function') {
      console.log('使用window.app对象');
      return {
        commandQueue: [],
        executeQueuedCommands: () => {
          console.log('window.app代理：使用全局方法执行队列命令');
          return true;
        },
        zoomModel: (params) => window.app.zoomComponent(null, params.scale),
        rotateModel: (params) => window.app.rotateComponent(null, params.angle, params.direction),
        focusModel: (params) => window.app.focusOnComponent(params.target),
        resetModel: () => window.app.resetModel ? window.app.resetModel() : false
      };
    }
  } catch (e) {
    console.error('使用全局app对象获取模型查看器引用失败:', e);
  }
  
  console.warn('无法找到模型查看器引用');
  return null;
};

// 尝试直接执行操作
const tryExecuteDirectOperations = (modelViewer) => {
  // 从会话存储中获取最后请求的操作类型
  const lastOpType = sessionStorage.getItem('last_mcp_operation_type');
  if (!lastOpType) return;
  
  console.log(`尝试直接执行最后请求的操作: ${lastOpType}`);
  
  // 检查是否使用全局window对象上的方法
  if (lastOpType === 'zoom' && typeof window.zoomModel === 'function') {
    const scale = parseFloat(sessionStorage.getItem('requested_scale') || '1.5');
    console.log(`尝试使用全局zoomModel: scale=${scale}`);
    try {
      window.zoomModel({ scale });
      return true;
    } catch (e) {
      console.error('使用全局zoomModel失败:', e);
    }
  }
  
  if (lastOpType === 'rotate' && typeof window.rotateModel === 'function') {
    const angle = parseInt(sessionStorage.getItem('requested_angle') || '45');
    const direction = sessionStorage.getItem('requested_direction') || 'left';
    console.log(`尝试使用全局rotateModel: angle=${angle}, direction=${direction}`);
    try {
      window.rotateModel({ direction, angle });
      return true;
    } catch (e) {
      console.error('使用全局rotateModel失败:', e);
    }
  }
  
  if (lastOpType === 'focus' && typeof window.focusModel === 'function') {
    const target = sessionStorage.getItem('requested_target') || 'center';
    console.log(`尝试使用全局focusModel: target=${target}`);
    try {
      window.focusModel({ target });
      return true;
    } catch (e) {
      console.error('使用全局focusModel失败:', e);
    }
  }
  
  if (lastOpType === 'reset' && typeof window.resetModel === 'function') {
    console.log(`尝试使用全局resetModel`);
    try {
      window.resetModel();
      return true;
    } catch (e) {
      console.error('使用全局resetModel失败:', e);
    }
  }
  
  // 根据操作类型调用不同方法
  if (!modelViewer) return false;
  
  switch(lastOpType.toLowerCase()) {
    case 'rotate':
      const angle = parseInt(sessionStorage.getItem('requested_angle') || '45');
      const direction = sessionStorage.getItem('requested_direction') || 'left';
      
      if (modelViewer.rotateComponent) {
        console.log(`直接执行旋转操作: 角度=${angle}, 方向=${direction}`);
        modelViewer.rotateComponent(null, angle, direction);
        return true;
      }
      break;
      
    case 'zoom':
      const scale = parseFloat(sessionStorage.getItem('requested_scale') || '1.5');
      
      if (modelViewer.zoomComponent) {
        console.log(`直接执行缩放操作: 比例=${scale}`);
        modelViewer.zoomComponent(null, scale);
        return true;
      }
      break;
      
    case 'focus':
      const target = sessionStorage.getItem('requested_target') || 'center';
      
      if (modelViewer.focusOnComponent) {
        console.log(`直接执行聚焦操作: 目标=${target}`);
        modelViewer.focusOnComponent(target);
        return true;
      }
      break;
      
    case 'reset':
      if (modelViewer.resetModel) {
        console.log('直接执行重置操作');
        modelViewer.resetModel();
        return true;
      }
      break;
  }
  
  return false;
};

// 快速检测操作类型
const detectOperation = (message: string) => {
  // 简单的命令识别逻辑
  let operation = null, parameters = {};

  if (message.includes('旋转')) {
    operation = 'rotate';
    
    // 检测角度
    const angleMatch = message.match(/(\d+)\s*度/);
    const angle = angleMatch ? parseInt(angleMatch[1]) : 45;
    
    // 检测方向
    const direction = message.includes('右') ? 'right' : 'left';
    
    // 保存用户请求的角度和方向到sessionStorage，确保其他组件可以访问
    sessionStorage.setItem('requested_angle', angle.toString());
    sessionStorage.setItem('requested_direction', direction);
    console.log(`检测到旋转角度: ${angle}°, 方向: ${direction}，已保存到sessionStorage`);
    
    // 添加额外的日志用于调试
    console.log('保存旋转参数到全局', {angle, direction});
    
    // 保存到全局对象，确保整个应用可以访问
    window.lastRequestedRotation = {
      angle,
      direction,
      timestamp: Date.now()
    };
    
    parameters = {
      direction: direction,
      angle: angle
    };
  } else if (message.includes('缩放') || message.includes('放大') || message.includes('缩小')) {
    operation = 'zoom';
    
    // 提取比例
    const scaleMatch = message.match(/(\d+(\.\d+)?)\s*倍/);
    let scale = scaleMatch ? parseFloat(scaleMatch[1]) : 1.5;
    
    if (message.includes('缩小') && scale > 1) {
      scale = 1 / scale;
    }
    
    parameters = { scale };
  } else if (message.includes('聚焦') || message.includes('关注')) {
    operation = 'focus';
    parameters = { 
      target: message.includes('中心') ? 'center' : 
              message.includes('会议') ? 'meeting' : 
              message.includes('办公') ? 'office' : 'model'
    };
  } else if (message.includes('重置') || message.includes('复位')) {
    operation = 'reset';
  }
  
  if (operation) {
    console.log(`检测到操作: ${operation}，参数:`, parameters);
  }
  
  return operation ? { operation, parameters } : null;
};

// 发送消息到Dify服务器并处理响应
const sendToDifyServer = async (message: string) => {
  try {
    console.log('发送消息到AI服务:', message);
    
    // 检测是否包含操作指令 (用于备用)
    const detectedOperation = detectOperation(message);
    
    // 记录操作类型到会话存储，防止重复执行
    if (detectedOperation) {
      sessionStorage.setItem('last_mcp_operation_type', detectedOperation.operation);
      sessionStorage.setItem('last_mcp_operation_time', Date.now().toString());
      console.log(`已记录操作类型: ${detectedOperation.operation}，防止重复执行`);
    }
    
    // 尝试使用本地API服务，而非Dify API
    const response = await fetch('http://localhost:8089/api/chat', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        message: message,
        model: 'default',
        detect_operation: true  // 添加标志，告诉后端需要检测操作指令
      })
    });
    
    if (!response.ok) {
      throw new Error(`API错误: ${response.status}`);
    }
    
    // 处理API响应
    const apiResponse = await response.json();
    console.log('收到AI服务响应:', apiResponse);
    
    // 提取回复文本
    const reply = apiResponse.text || 
                  apiResponse.response || 
                  apiResponse.answer || 
                  apiResponse.message || 
                  '无法获取AI回复';
    
    // 如果后端返回了操作指令
    if (apiResponse.action) {
      console.log('收到AI服务的操作指令:', apiResponse.action);
      
      // 记录操作类型到会话存储，防止重复执行
      const actionType = apiResponse.action.type || apiResponse.action.operation;
      if (actionType) {
        sessionStorage.setItem('last_mcp_operation_type', actionType);
        sessionStorage.setItem('last_mcp_operation_time', Date.now().toString());
        console.log(`已记录操作类型: ${actionType}，防止重复执行`);
      }
      
      // 返回格式化的响应
      return {
        text: reply,
        success: true,
        operation: actionType,
        parameters: apiResponse.action.params || apiResponse.action.parameters,
        action: apiResponse.action
      };
    }
    
    // 检查是否从回复内容中解析操作命令
    const actionMatch = reply.match(/\[(.*?)\]\((.*?)\)/);
    if (actionMatch) {
      try {
        const actionText = actionMatch[1];
        const actionCommand = actionMatch[2];
        const action = JSON.parse(actionCommand);
        
        console.log('从回复内容解析得到操作:', action);
        
        // 记录操作类型到会话存储，防止重复执行
        const actionType = action.type || action.operation;
        if (actionType) {
          sessionStorage.setItem('last_mcp_operation_type', actionType);
          sessionStorage.setItem('last_mcp_operation_time', Date.now().toString());
          console.log(`已记录操作类型: ${actionType}，防止重复执行`);
        }
        
        return {
          text: reply,
          success: true,
          operation: actionType,
          parameters: action.params || action.parameters,
          action: action
        };
      } catch (e) {
        console.error('解析操作命令失败:', e);
      }
    }
    
    // 注释掉本地检测到操作指令时立即执行的部分
    // 如果后端未检测到操作指令，但我们本地检测到了，不做任何操作
    // 让操作统一通过AI回复后的回调来执行
    if (detectedOperation) {
      console.log('本地检测到操作指令，但不立即执行，等待AI响应:', detectedOperation.operation);
      
      // 仍然返回检测到的操作信息，以便AI响应回调时使用
      if (detectedOperation.operation) {
        return {
          text: reply,
          success: true,
          operation: detectedOperation.operation,
          parameters: detectedOperation.parameters,
          action: {
            type: detectedOperation.operation,
            params: detectedOperation.parameters
          }
        };
      }
    }
    
    // 如果没有检测到操作指令或MCP服务不可用，返回普通响应
    return {
      text: reply,
      success: true
    };
  } catch (error) {
    console.error('发送消息到AI服务失败:', error);
    return {
      text: `我遇到了一些问题，请稍后再试。详情: ${error.message}`,
      success: false
    };
  }
};

// 直接执行MCP操作
const executeMCPOperation = async (operation: string, parameters: any) => {
  try {
    if (!isMCPAvailable.value) {
      throw new Error('MCP服务不可用');
    }
    
    console.log(`执行MCP操作: ${operation}`, parameters);
    
    // 调用MCP execute接口
    const response = await fetch('http://localhost:9000/api/execute', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        action: operation,
        parameters: parameters
      })
    });
    
    if (!response.ok) {
      throw new Error(`MCP操作失败: ${response.status}`);
    }
    
    const result = await response.json();
    return {
      success: result.success || result.status === 'success',
      operation: operation,
      parameters: parameters,
      message: result.message || `${operation}操作已执行`
    };
  } catch (error) {
    console.error('MCP操作执行失败:', error);
    throw error;
  }
};

// 检查MCP服务器状态 (Check MCP server status)
const checkMCPServerStatus = async () => {
  try {
    const response = await fetch('http://localhost:9000/health');
    
    if (response.ok) {
      const data = await response.json();
      
      // 增加调试信息
      console.log('MCP服务健康检查响应:', data);
      
      // 更新健康检查判断条件，增加状态判断的容错性
      if (data.status === 'healthy' || data.status === 'ok' || data.browser_status === 'healthy' || data.browser_status === '已初始化') {
        mcpServerStatus.value = 'online';
        console.log('MCP服务状态已设置为online');
      } else if (data.status === 'degraded' || data.browser_status === 'degraded') {
        mcpServerStatus.value = 'degraded';
        console.log('MCP服务状态已设置为degraded');
      } else {
        mcpServerStatus.value = 'offline';
        console.log('MCP服务状态已设置为offline，原因:', data.status);
      }
    } else {
      mcpServerStatus.value = 'offline';
      console.log('MCP服务健康检查失败，状态码:', response.status);
    }
  } catch (error) {
    console.error('MCP服务状态检查失败:', error);
    mcpServerStatus.value = 'offline';
  }
  
  // 验证WebSocket连接状态
  try {
    // 尝试通过其他方式确认WebSocket连接
    const wsTestResponse = await fetch('http://localhost:9000/api/websocket/status');
    
    if (wsTestResponse.ok) {
      const wsStatus = await wsTestResponse.json();
      console.log('WebSocket状态检查结果:', wsStatus);
      
      // 如果WebSocket已连接但MCP服务状态为offline，强制更新状态
      if (wsStatus.connected && mcpServerStatus.value === 'offline') {
        mcpServerStatus.value = 'online';
        console.log('基于WebSocket状态，强制更新MCP服务状态为online');
      }
    }
  } catch (error) {
    // 忽略这个错误，因为这个API可能不存在
    console.log('WebSocket状态检查API未找到，跳过');
  }
  
  // 直接设置为可用，用于临时修复
  if (mcpServerStatus.value === 'offline') {
    console.log('临时解决方案：将MCP状态设置为online以启用模型操作模式');
    mcpServerStatus.value = 'online';
  }
};

// 格式化时间 (Format time)
function formatTime(date: Date): string {
  return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
}

// 滚动到底部 (Scroll to bottom)
function scrollToBottom() {
  if (chatContainerRef.value) {
    chatContainerRef.value.scrollTop = chatContainerRef.value.scrollHeight;
  }
}

// 示例功能 (Example functionality)
const fillExample = (example: string) => {
  userMessage.value = example;
};

// 添加直接切换到模型操作模式的功能
const enableModelControlMode = () => {
  // 保存之前的状态用于调试
  const prevStatus = mcpServerStatus.value;
  
  // 直接设置为在线状态
  mcpServerStatus.value = 'online';
  
  console.log('已强制启用模型操作模式，之前的状态为:', prevStatus);
};

// 检查MCP客户端连接状态
const checkMCPConnection = async () => {
  // 检查MCP客户端是否已初始化
  if (!mcpClient.value) {
    console.log('MCP客户端未初始化，尝试初始化');
    try {
      // 添加必要的配置信息
      const mcpConfig = {
        serverUrl: 'http://localhost:9000',
        wsUrl: 'ws://localhost:9000/ws/mcp',
        autoReconnect: true,
        reconnectDelay: 3000,
        maxReconnectAttempts: 5,
        pingInterval: 30000,
        clientType: 'web_ui',
        onMessage: (message) => {
          console.log('收到MCP消息:', message);
        },
        onStatusChange: (status) => {
          console.log('MCP状态变更为:', status);
        }
      };
      
      mcpClient.value = getMCPClient(mcpConfig);
      console.log('MCP客户端初始化成功');
    } catch (error) {
      console.error('MCP客户端初始化失败:', error);
      return false;
    }
  }
  
  // 检查连接状态
  if (mcpClient.value && (!mcpClient.value.connected || mcpClient.value.connected.value === false)) {
    console.log('MCP客户端未连接，尝试连接');
    try {
      mcpClient.value.connect();
    } catch (error) {
      console.error('MCP客户端连接失败:', error);
      return false;
    }
  }
  
  return true;
};

// 组件挂载后 (After component mount)
onMounted(() => {
  scrollToBottom();
  // 立即检查MCP服务状态
  checkMCPServerStatus();
  
  // 初始化MCP客户端
  try {
    // 添加必要的配置信息
    const mcpConfig = {
      serverUrl: 'http://localhost:9000',
      wsUrl: 'ws://localhost:9000/ws/mcp',
      autoReconnect: true,
      reconnectDelay: 3000,
      maxReconnectAttempts: 5,
      pingInterval: 30000,
      clientType: 'web_ui',
      onMessage: (message) => {
        console.log('收到MCP消息:', message);
      },
      onStatusChange: (status) => {
        console.log('MCP状态变更为:', status);
      }
    };
    
    mcpClient.value = getMCPClient(mcpConfig);
    console.log('MCP客户端初始化成功');
    
    // 建立连接
    if (mcpClient.value) {
      mcpClient.value.connect();
    }
  } catch (error) {
    console.error('MCP客户端初始化失败:', error);
  }
  
  // 先进行一次快速检查，确保服务状态尽快更新
  setTimeout(() => {
    checkMCPServerStatus();
    // 同时检查MCP连接
    checkMCPConnection();
  }, 1000);
  
  // 声明变量并初始化为0或null以避免未定义错误
  let statusCheckInterval = 0;
  let mcpCheckInterval = 0;
  
  // 然后每5秒检查一次MCP服务状态，确保状态及时更新
  statusCheckInterval = window.setInterval(() => {
    checkMCPServerStatus();
  }, 5000);
  
  // 每10秒检查一次MCP连接状态
  mcpCheckInterval = window.setInterval(() => {
    checkMCPConnection();
  }, 10000);
  
  // 暴露API到全局窗口
  if (window) {
    window.enableMCPMode = enableModelControlMode;
  }
  
  // 组件卸载时清除定时器
  onBeforeUnmount(() => {
    if (statusCheckInterval) window.clearInterval(statusCheckInterval);
    if (mcpCheckInterval) window.clearInterval(mcpCheckInterval);
    
    // 清除全局API
    if (window && window.enableMCPMode) {
      delete window.enableMCPMode;
    }
  });
});

// 增加MCP处理能力
// 注意：我们不再直接使用getMCPClient，只通过API调用和HTTP请求来处理
// import { getMCPClient } from '../utils/MCPClient';

// 处理消息
const handleMessage = async (message: string) => {
  if (!message.trim()) return;
  
  // 添加用户消息到聊天记录
  chatHistory.push({
    role: 'user',
    content: message,
    time: formatTime(new Date())
  });
  
  // 清空输入框 - 修复这里对userMessage的引用
  if (userMessage && typeof userMessage.value !== 'undefined') {
    userMessage.value = '';
  }
  
  // 显示加载状态
  isLoading.value = true;
  
  try {
    // 检测操作指令
    const detectedOperation = detectOperation(message);
    
    // 如果检测到操作指令，先注册但不立即执行
    let pendingCommandKey = null;
    if (detectedOperation) {
      pendingCommandKey = commandStateManager.registerCommand(
        detectedOperation.operation, 
        detectedOperation.parameters
      );
      sessionStorage.setItem('pending_command_key', pendingCommandKey);
      console.log(`已注册操作指令: ${detectedOperation.operation}，等待AI响应后执行`);
    }
    
    // 尝试从自然语言生成MCP命令
    if (isMCPAvailable.value) {
      // 发送自然语言命令请求
      const response = await fetch(
        'http://localhost:9000/api/mcp/nl-command', 
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ message })
        }
      );
      
      if (response.ok) {
        const result = await response.json();
        
        if (result.success) {
          // 添加AI响应
          chatHistory.push({
            role: 'assistant',
            content: `我已执行您的指令: ${result.action}`,
            time: formatTime(new Date()),
            mcpOperation: {
              operation: result.action,
              parameters: result.parameters,
              success: result.result?.success || false
            }
          });
          
          // 确保UI更新，AI回复显示出来
          await nextTick();
          scrollToBottom();
          
          // 如果是旋转操作，检查并修正角度
          if (result.action === 'rotate' && result.parameters) {
            // 确保角度参数正确，如果用户要求45度但被设置为30度，则修复它
            const userAngle = message.match(/(\d+)\s*度/) ? parseInt(message.match(/(\d+)\s*度/)[1]) : null;
            if (userAngle && result.parameters.angle && result.parameters.angle !== userAngle) {
              console.log(`修正旋转角度: 从${result.parameters.angle}°改为${userAngle}°`);
              result.parameters.angle = userAngle;
            }
          }
          
          // 延迟执行操作，获取执行锁
          if (commandStateManager.acquireLock()) {
            try {
              console.log('延迟执行模型操作，等待AI回复显示...');
              await delay(1000);
              
              // 检查是否近期已执行过相似命令
              if (!commandStateManager.isCommandExecuted(result.action, result.parameters)) {
                // 延迟后发出操作事件
                console.log('现在执行模型操作:', result.action);
                emit('executeAction', {
                  type: result.action,
                  operation: result.action,
                  parameters: result.parameters
                });
                
                // 标记命令已执行
                if (pendingCommandKey) {
                  commandStateManager.markAsExecuted(pendingCommandKey);
                } else {
                  // 注册并标记新命令为已执行
                  const newCommandKey = commandStateManager.registerCommand(
                    result.action,
                    result.parameters
                  );
                  commandStateManager.markAsExecuted(newCommandKey);
                }
              } else {
                console.log(`近期已执行过相似的${result.action}命令，跳过执行`);
              }
            } finally {
              // 释放执行锁
              commandStateManager.releaseLock();
            }
          }
          
          isLoading.value = false;
          return;
        }
      }
    }
    
    // 如果不是MCP命令或MCP命令处理失败，继续使用AI处理
    await sendToAI(message);
  } catch (error) {
    console.error('处理消息出错:', error);
    
    // 添加错误消息
    chatHistory.push({
      role: 'assistant',
      content: `处理消息时出错: ${error instanceof Error ? error.message : String(error)}`,
      time: formatTime(new Date())
    });
  } finally {
    isLoading.value = false;
    
    // 滚动到底部
    scrollToBottom();
  }
};

// 使用AI处理消息
const sendToAI = async (message: string) => {
  try {
    const model = selectedModel.value;
    
    // 发送API请求
    const response = await fetch(
      'http://localhost:8089/api/chat',
      {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ message, model })
      }
    );
    
    if (!response.ok) {
      throw new Error(`API请求失败: ${response.status}`);
    }
    
    const result = await response.json();
    
    // 添加AI响应到聊天记录
    chatHistory.push({
      role: 'assistant',
      content: result.response || result.message || result.text || '无响应',
      time: formatTime(new Date())
    });
    
    // 确保UI更新，AI回复显示出来
    await nextTick();
    scrollToBottom();
    
    // 延迟执行操作，确保AI回复先显示
    console.log('延迟执行模型操作，等待AI回复显示...');
    await delay(1000);
    
    // 如果返回了操作指令
    if (result.action) {
      try {
        // 标准化操作类型和参数
        const operation = result.action.type || result.action.operation;
        const parameters = result.action.params || result.action.parameters || {};
        
        if (!operation) {
          console.warn('操作指令缺少类型:', result.action);
          return;
        }
        
        console.log(`执行AI返回的操作: ${operation}`, parameters);
        
        // 添加操作记录
        chatHistory.push({
          role: 'assistant',
          content: `执行操作: ${operation}`,
          time: formatTime(new Date()),
          mcpOperation: {
            operation,
            parameters,
            success: true
          }
        });
        
        // 延迟后发出操作事件
        console.log('现在执行模型操作:', operation);
        emit('executeAction', {
          type: operation,
          operation,
          params: parameters,
          parameters
        });
        
        // 执行队列中的命令
        executeQueuedCommands();
      } catch (actionError) {
        console.error('执行AI返回的操作失败:', actionError);
        
        // 添加错误信息
        chatHistory.push({
          role: 'assistant',
          content: `操作执行失败: ${actionError instanceof Error ? actionError.message : String(actionError)}`,
          time: formatTime(new Date())
        });
      }
    }
  } catch (error) {
    console.error('AI请求出错:', error);
    
    // 添加错误消息
    chatHistory.push({
      role: 'assistant',
      content: `AI处理失败: ${error instanceof Error ? error.message : String(error)}`,
      time: formatTime(new Date())
    });
  }
};

// 暴露方法给父组件
defineExpose({
  enableModelControlMode
});
</script>

<template>
  <div class="chat-dialog" v-if="modelVisible">
    <div class="chat-header">
      <h2>AI 助手对话 (AI Assistant Chat)</h2>
      <button class="close-button" @click="closeDialog">×</button>
    </div>
    
    <div class="chat-status">
      <!-- MCP状态指示器 -->
      <div class="mcp-status" :class="mcpServerStatus">
        <span class="status-dot"></span>
        <span>{{ mcpServerStatus === 'online' ? 'MCP服务已连接' : 
                 mcpServerStatus === 'degraded' ? 'MCP服务状态异常' : 
                 'MCP服务未连接' }}</span>
        <button 
          v-if="mcpServerStatus !== 'online'" 
          class="force-enable-btn" 
          @click="enableModelControlMode"
          title="强制启用模型操作模式，用于前端调试"
        >
          强制启用
        </button>
      </div>
      
      <!-- 一体化模式说明 -->
      <div class="mode-description">
        <p>
          <i class="mode-icon">🤖</i> AI助手可以回答问题和操作3D模型
        </p>
      </div>
    </div>
    
    <div class="chat-examples">
      <span>示例: </span>
      <!-- 混合示例 -->
      <button @click="fillExample('办公室哪个区域是会议室？')">办公室哪个区域是会议室？</button>
      <button @click="fillExample('向左旋转模型45度')">向左旋转模型45度</button>
      <button @click="fillExample('将模型放大1.5倍')">将模型放大1.5倍</button>
      <button @click="fillExample('聚焦到中心区域')">聚焦到中心区域</button>
      <button @click="fillExample('重置模型视图')">重置模型视图</button>
    </div>
    
    <div class="chat-container" ref="chatContainerRef">
      <div v-for="(message, index) in chatHistory" :key="index" 
          :class="['message', message.role === 'user' ? 'user-message' : 'assistant-message']">
        <div class="message-content">
          <span class="message-role">{{ message.role === 'user' ? '您' : 'AI助手' }}</span>
          <span class="message-time">{{ message.time }}</span>
          <p>{{ message.content }}</p>
          <div v-if="message.mcpOperation" class="operation-info">
            <span class="operation-badge">
              {{ message.mcpOperation.operation }}
              <span v-if="message.mcpOperation.success" class="success">✓</span>
              <span v-else class="failed">✗</span>
            </span>
          </div>
        </div>
      </div>
      
      <div v-if="isLoading" class="loading-indicator">
        <span>AI思考中...</span>
      </div>
    </div>
    
    <div class="chat-input">
      <textarea 
        v-model="userMessage" 
        placeholder="输入您的问题或指令..."
        @keyup.enter="sendMessage"
      ></textarea>
      <button @click="sendMessage" :disabled="isLoading || !isMCPAvailable">发送</button>
    </div>
  </div>
</template>

<style scoped>
.chat-dialog {
  position: fixed;
  bottom: 20px;
  right: 20px;
  width: 400px;
  height: 600px;
  background-color: white;
  border-radius: 10px;
  box-shadow: 0 0 20px rgba(0,0,0,0.1);
  display: flex;
  flex-direction: column;
  z-index: 1000;
}

.chat-header {
  padding: 15px;
  background-color: #4CAF50;
  color: white;
  border-radius: 10px 10px 0 0;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.chat-header h2 {
  margin: 0;
  font-size: 18px;
}

.close-button {
  background: none;
  border: none;
  color: white;
  font-size: 24px;
  cursor: pointer;
}

.chat-status {
  padding: 10px 15px;
  background-color: #f5f5f5;
  display: flex;
  flex-direction: column;
  gap: 8px;
  border-bottom: 1px solid #e0e0e0;
}

.mcp-status {
  display: flex;
  align-items: center;
  gap: 5px;
  font-size: 12px;
}

.status-dot {
  display: inline-block;
  width: 8px;
  height: 8px;
  border-radius: 50%;
}

.mcp-status.online .status-dot {
  background-color: #4CAF50;
}

.mcp-status.degraded .status-dot {
  background-color: #FFC107;
}

.mcp-status.offline .status-dot, 
.mcp-status.unknown .status-dot {
  background-color: #F44336;
}

.force-enable-btn {
  margin-left: 10px;
  padding: 2px 6px;
  font-size: 11px;
  background-color: #4CAF50;
  color: white;
  border: none;
  border-radius: 3px;
  cursor: pointer;
}

.force-enable-btn:hover {
  background-color: #388E3C;
}

.chat-examples {
  padding: 10px 15px;
  background-color: #f9f9f9;
  display: flex;
  flex-wrap: wrap;
  gap: 5px;
  align-items: center;
}

.chat-examples button {
  background-color: #e8f5e9;
  border: 1px solid #c8e6c9;
  color: #388e3c;
  border-radius: 15px;
  padding: 5px 10px;
  font-size: 12px;
  cursor: pointer;
}

.chat-container {
  flex: 1;
  overflow-y: auto;
  padding: 15px;
  background-color: #f9f9f9;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.message {
  max-width: 80%;
  padding: 10px;
  border-radius: 10px;
  position: relative;
}

.user-message {
  align-self: flex-end;
  background-color: #dcf8c6;
  margin-left: 20%;
}

.assistant-message {
  align-self: flex-start;
  background-color: white;
  margin-right: 20%;
}

.message-role {
  font-weight: bold;
  font-size: 12px;
}

.message-time {
  font-size: 10px;
  color: #666;
  margin-left: 5px;
}

.message p {
  margin: 5px 0 0 0;
  white-space: pre-wrap;
}

.operation-info {
  margin-top: 5px;
  font-size: 12px;
}

.operation-badge {
  display: inline-block;
  padding: 2px 8px;
  background-color: #f1f1f1;
  border-radius: 10px;
  color: #555;
}

.operation-badge .success {
  color: #4CAF50;
}

.operation-badge .failed {
  color: #F44336;
}

.loading-indicator {
  align-self: center;
  padding: 5px 10px;
  background-color: #f1f1f1;
  border-radius: 10px;
  font-size: 12px;
  color: #555;
}

.chat-input {
  padding: 15px;
  background-color: white;
  display: flex;
  gap: 10px;
  border-top: 1px solid #e0e0e0;
}

.chat-input textarea {
  flex: 1;
  height: 60px;
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: 5px;
  resize: none;
}

.chat-input button {
  padding: 0 20px;
  background-color: #4CAF50;
  color: white;
  border: none;
  border-radius: 5px;
  cursor: pointer;
}

.chat-input button:disabled {
  background-color: #cccccc;
  cursor: not-allowed;
}

.mode-description {
  font-size: 12px;
  color: #666;
  margin-top: 5px;
}

.mode-description p {
  margin: 0;
  display: flex;
  align-items: center;
}

.mode-icon {
  font-style: normal;
  margin-right: 5px;
}
</style> 